第 13 章 元表与元方法
=====================

当lua视图将两个table相加时，他会先检查两者之一是否有元表，然后检查该元表中是否有一个叫__add的字段。若找到了该字段则调用该字段对应的值。这个值就是所谓的元方法，它该是一个函数，用于计算table的和。

lua中每个值都有一个元表，table和userdata可以有各自的元表，而其他类型值则共享其类型所属的单一元表。**lua在创建新table时，不会去创建元表。**

可以用setmetatable来设置或者修改任何table的元表。

任何table都可以作为任何值的元表，一组相关的table也可以共享一个通用的元表，该元素描述了他们的共同行为。一个table甚至可以作为自己的元表，用于描述其特有的行为。总之，任何搭配形式都是合法的。

在lua中只能设置table的元素，若想设置其他类型的元素需要在c代码中完成。

在第20章中，标准字符串程序库为所有字符串都设置了元表，而其他类型默认是没有的。

## 13\.1 算术类的元方法

在元表中，每种算法都有自己对应的字段名。

* __add
* __mul
* __sub
* __div
* __unm(相反数)
* __mod
* __pow
* __concat


lua按照如下步骤来查找元表:

* 若第一个值有元表并元表中有__add字段，那么lua就以这个字段为元方法，而与第二个值无关
* 若第二个值有元表并含有__add字段，lua就以此字段为元方法
* 若两个值都无元方法，则引发一个错误

## 13\.2 关系类的元方法

元表还可以指定关系操作符的含义

* __eq
* __lt（小于）
* __le（小于等于）

其他关系操作符没有单独的元方法，lua会将`a ~= b`转换为`not (a == b)`，将`a > b`转为`b < a`， 将`a >= b`转为`b <= a`


与算术类元方法不同的是，关系类的元方法不能应用于混合类型。对于混合类型而言，关系类元方法的行为就模拟这些操作在lua中普通行为。如果试图将一个字符串与一个数字作顺序性比较，lua会引发一个错误。

等于比较永远不会引发错误，但是如果两对象有用不同元方法，那么等操作不会调用任何一个元方法，而会直接返回`false`

## 13\.3 库定义的元方法

函数`setmetatable`和`getmetatable`也会用到元表中的一个字段，用于保护元表，假设想要保护集合元表，使用户既不能看到也不能修改集合元表。那么就需要用到字段`__metatable`当设置了该字段时，`getmetatable`便会返回该字段的值，而`setmetatable`会引发一个错误。

## 13\.4

### 1\. table 访问元方法

当访问一个`table`中不存在的字段时，得到的结果为`nil`，解释器回去查找一个`__index`元方法。

* 若找不到，返回nil
* 否则由这个方法来提供最终结果

在`lua`中，将`__index`元方法用于继承是很普遍的方法，因此`lua`还提供了一种更加便捷的方式来实现此功能，`__index`元方法不必议定书一个函数，他还可以是一个`table`

* 当它是一个table的时候，lua以相同的方式来重新访问这个table
* 当它是一个函数时，lua以table和不存在的key作为参数来调用该函数

### 2\. __newindex元方法

__newindex元方法与__index类似，不同之处在于前者用于table的更新，后者用于table的查询。当对一个table中不存在的索引赋值时，解释器就会查找__newindex元方法:

* 若果有这个元方法则调用，而不是执行赋值
* 如果这个元方法是一个table，则对这个table赋值，而不是对原来的table赋值。

调用rawset(t, k, v)便可不涉及任何元方法，直接对此table赋值

```lua
function setDefualt(t, d)
    local mt = {__index = function()
            return d
        end
    }
    setmetatable(t, mt)
end
-- 具有默认值的table
tab = {x = 10, y = 20}
print (tab.x, tab.y)    --> 10, nil
setDefalut(tab, 0)
print (tab.x, tab.z)    --> 10, 0
```
---------

```lua
-- 保证名称不冲突
local key = {}
local mt = {__index = function (t)
        return t[key]
    end
}

function setDefalut(t, d)
    t[key] = d
    setmetatable(t, mt)
end
```

> 弱引用，17章，备忘录(memoize)




### 4\. 跟踪table的访问

__index和__newindex都是在table中没有所需访问的index时才起作用。因此，只有将一个table保持为空，才有可能捕捉到所有对它的访问。为了见识一个table的所有访问，就应该为真正的table简历一个代理，这个代理就是一个空的table，其中__index和__newindex元方法可用于跟踪所有访问，并将访问重定向到原来的table上。

### 5\. 只读table

只需跟踪所有对table的更新操作，并引发一个错误就可以了。

